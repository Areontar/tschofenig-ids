<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="no"?>
<?rfc iprnotified="no" ?>
<?rfc strict="no" ?>
<?rfc compact="no" ?>
<?rfc subcompact="no" ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC5849 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5849.xml">
<!ENTITY RFC4949 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4949.xml">
<!ENTITY I-D.ietf-oauth-v2 SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-v2.xml">
<!ENTITY I-D.ietf-oauth-json-web-token SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-json-web-token.xml">
<!ENTITY RFC4279 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4279.xml">
<!ENTITY RFC5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY RFC4962 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4962.xml">
<!ENTITY RFC4120 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4120.xml">
<!ENTITY RFC6125 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6125.xml">
<!ENTITY RFC5056 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5056.xml">
<!ENTITY I-D.tschofenig-oauth-hotk SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.tschofenig-oauth-hotk.xml">
<!ENTITY I-D.ietf-oauth-v2-http-mac SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-v2-http-mac.xml">
<!ENTITY I-D.hardjono-oauth-kerberos SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.hardjono-oauth-kerberos.xml">
<!ENTITY I-D.iab-privacy-considerations SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.iab-privacy-considerations.xml">
<!ENTITY I-D.rescorla-stateless-tokens SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.rescorla-stateless-tokens.xml">
<!ENTITY I-D.ietf-oauth-v2-bearer SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-v2-bearer.xml">
]>
<rfc category="info" docName="draft-tschofenig-oauth-security-00.txt" ipr="trust200902">
  <front>
    <title abbrev="OAuth Security">OAuth Security: </title>   
    <author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
      <organization>Nokia Siemens Networks</organization>
      <address>
        <postal>
          <street>Linnoitustie 6</street>
          <city>Espoo</city>
          <code>02600</code>
          <country>Finland</country>
        </postal>
        <phone>+358 (50) 4871445</phone>
        <email>Hannes.Tschofenig@gmx.net</email>
        <uri>http://www.tschofenig.priv.at</uri>
      </address>
    </author>
          <author fullname="Phil Hunt" initials="P." surname="Hunt">
      <organization>Oracle Corporation</organization>

      <address>
        <email>phil.hunt@yahoo.com</email>
      </address>
    </author>

    <date year="2012"/>
    <area>Security Area</area>
    <workgroup>OAuth</workgroup>
    <keyword>Internet-Draft</keyword>
    <keyword>OAuth</keyword>
    <keyword>Signatures</keyword>
    <keyword>Security</keyword>
    <keyword>Message Authentication</keyword>
    <abstract>
      <t>The OAuth working group has finished work on the OAuth 2.0 core protocol as well as the Bearer Token specification. The Bearer Token is a TLS-based solution for ensuring that neither the interaction with the Authorization Server (when requesting atoken) nor the interaction with the Resource Server (for accessing a protected resource) leads to token leakage.
      There has, however, always been the desire to develop a security solution that is "better" than Bearer Tokens (or at least different) where the Client needs to show possession of some keying material when accessing a Resource Server. This document tries to capture the discussion and to come up with requirements to process the work on solutions.</t>
      
      <t>This document aims to discuss threats, security requirements and desired design properties of an OAuth security mechanism that offers more advanced security properties.</t>
    </abstract>
  </front>

  <middle>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="introduction" title="Introduction">
    <t>The initial version of the Open Web Authentication Protocol (OAuth 1.0, <xref target="RFC5849"/>) included an 
      mechanism for putting a digital signature (when using asymmetric keys) or a keyed message digest (when using symmetric keys) to a resource request when presenting the OAuth token.
      OAuth 2.0 <xref target="I-D.ietf-oauth-v2"/> generalized the structure and has currently the Bearer Token security specification <xref target="I-D.ietf-oauth-v2-bearer"/> close to publication as an RFC. We later explain the properties of the Bearer Token security mechanism.
            
          <figure anchor="oauth-simplified" title="OAuth: Abstract Protocol Flow">
            <artwork>
              <![CDATA[
     +--------+                               +---------------+
     |        |--(A)- Authorization Request ->|   Resource    |
     |        |                               |     Owner     |
     |        |<-(B)-- Authorization Grant ---|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(C)-- Authorization Grant -->| Authorization |
     | Client |                               |     Server    |
     |        |<-(D)----- Access Token -------|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------>|    Resource   |
     |        |                               |     Server    |
     |        |<-(F)--- Protected Resource ---|               |
     +--------+                               +---------------+
                       ]]></artwork>
          </figure>
        </t>
<t><xref target="oauth-simplified"/> shows the OAuth exchange at an abstract level and introduces the main entities. For most parts of this document the focus is on the interaction between the Client and the Authorization Server and between the Client and the Resource Server.</t>

<t>From a security point of view the following aspects of the OAuth 2.0 specification are worth mentioning:

<list style="symbols">
<t>The format and content of the access token is not standardized (at this point in time) although work is in progress to standardize a JSON based structure and corresponding JSON security mechanisms).</t>
<t>The interaction to obtain an access token in step #1 mandates to implement and to use TLS with server-side authentication to protect the confidentiality of the transmitted information.</t>
</list>
</t>

    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="terminology" title="Terminology">

      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
        "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in
        RFC 2119 <xref target="RFC2119"/>.</t>

<t>This document uses the terminology defined in RFC 4949 <xref target="RFC4949"/>. The terms 'keyed hash' and 'keyed message digest' are used interchangable. For privacy related matters we utilize the terminology defined in <xref target="I-D.iab-privacy-considerations"/>.
</t>

<t>This document uses OAuth 2.0 terminology <xref target="I-D.ietf-oauth-v2"/>.</t>
    </section>


    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="threats" title="Security and Privacy Threats">
   
   <t>The following list presents several common threats against protocols utilizing some form of tokens. This list of threats is based on NIST Special Publication 800-63 <xref target="NIST800-63"/>. We exclude a discussion of threats related to any form of identity proofing and authentication of the resource owner to the authorizataion server since they are not part of the OAuth protocol itself.</t>
   <t><list style="hanging">
   <t hangText="Token manufacture/modification:"> An attacker may generate a bogus token or modify the token content (such as the authentication or attribute statements) of an existing token, causing Resource Server to grant inappropriate access to the Client. For example, an attacker may modify the token to extend the validity period; Client may modify the assertion to have access to information that they should not be able to view.</t>
   <t hangText="Token disclosure:">Tokens may contain personal data, such as real name, age or birthday, payment information, etc.</t>
<!--    <t hangText="Token repudiation:">A token may be repudiated if the proper mechanisms are not in place.</t> -->
   <t hangText="Token redirect:">An attacker uses the token generated for consumption by Resource Server to obtain access to a second Resource Server.</t>   <t hangText="Token reuse:"> An attacker attempts to use a token that has already been used once with Resource Server. The attacker may be an eavesdropper who observes the communication exchange or, worse, one of the communication end points. Client may, for example, leak access tokens since it cannot keep secrets confidential. Client may also re-use access token for Resource Server with some other protected resource. Finally, Resource Server may use a token it had obtained from Client and use it with another protected resouce that Client interacts with. Resource Server, offering relatively unimportant toy application services, may attempt to use an access token obtained from Client to access a high-value service, such as a payment service, on behalf of Client using the exact same access token.</t>
</list> 
</t>

<t>We excluded one threat from the list, namely 'token repudiation'. Token repudiation refers to a property whereby Resource Server is given an assurance that Authorization Server cannot deny to have created a token for Client. We believe that such a property is interesting but most deployments prefer to deal with the violation of this security property through business actions rather than by using cryptography.</t>
      
</section> 


    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

<section anchor="mitigation" title="Threat Mitigation"> 

<t>The purpose of this section is to discuss ways to mitigate the threats without taking the current working group status into consideration.
</t>

<t>A large range of threats can be mitigated by protecting the content of the token, using a digitial signature or a keyed message digest. Alternatively, the content of the token could be passed by reference rather than by value (requiring a separate message exchange to resolve the reference to the token content). To simplify the subsequent description we assume that the token itself is digitally signed by Authorization Server and therefore cannot be modified. <!-- This also provides the basis for non-repudiation.--> </t>

<t>To deal with token redirect it is important for Authorization Server to include the identity of the intended recipient, namely Resource Server. No service must be allowed to accept access tokens that are not meant for their consumption. </t>

<t>To provide protection against token disclosure two approaches are possible, namely (a) not to include sensitive information inside the token or (b) to ensure confidentiality protection. The latter feature requires at least the communication interaction between the Client and Authorization Server as well as the interaction between Client and Resource Server to experience confidentiality protection. As an example, Transport Layer Security with a ciphersuite that offers confidentiality protection has to be applied. Encrypting the token content itself is another alternative. In our scenario Authorization Server would, for example, encrypt the token content with a symmetric key she shares with Resource Server.  
</t>

<t>To deal with the last threat, namely token reuse, more choices are available.</t>

<section anchor="confidentiality" title="Confidentiality Protection">

<t>In this approach confidentiality protection of the exchange is provided on the communication interfaces between Client and Resource Server, and Client and Authorization Server. No eavesdropper on the wire is able to observe the token exchange. Consequently, a replay is not possible. Authorization Server wants to ensure that it only hands out tokens to entities it has authenticated first and who are authorized. For this purpose, authentication of Client to Authorization Server will be a requirement. This is, however, true for the description in <xref target="intended"/> and <xref target="confirmation"/> as well. Furthermore, Client has to make sure it does not distribute the token to entities other than Resource Server. For that purpose Client will have to authenticate Resource Server before transmitting the token.
</t>

</section> 

<section anchor="intended" title="Sender Constraint">

<t>Instead of providing confidentiality protection Carl could also put the identity of Client into the protected token with the following semantic: 'This token is only valid when presented by Client.' When the token is then presented to Resource Server how does he know that it was provided by Client? He has to authenticate Client! There are many choices for authenticating Client to Resource Server, such as, Client-side certificates in TLS <xref target="RFC5246"/>, or pre-shared secrets within TLS <xref target="RFC4279"/>. The choice of the preferred authentication mechanism and credential type may depend on a number of factors, including <list style="symbols"> 
<t>security properties</t>
<t>available infrastructure</t>
<t>library support</t>
<t>credential cost (financial)</t>
<t>performance</t>
<t>integration into the existing IT infrastructure</t>
<t>operational overhead for configuration and distribution of credentials</t>
</list> 
</t>
<t>This long list hints to the challenge of selecting at least one mandatory-to-implement mechanism.</t>

</section> 

<section anchor="confirmation" title="Key Confirmation">

<t>A variation of the mechanism of sender authentication described in <xref target="intended"/> is to replace authentication with the proof-of-possession of a specific key, i.e. key confirmation. In this model the Resource Server would not authenticate the Client but would rather verify whether the Client knows a secret. Examples of this approach can be found with OAuth 1.0 MAC token <xref target="RFC5849"/>, Kerberos <xref target="RFC4120"/> when utilizing the AP_REQ/AP_REP exchange (see <xref target="I-D.hardjono-oauth-kerberos"/> for a comparision between Kerberos and OAuth), OAuth 2.0 MAC token <xref target="I-D.ietf-oauth-v2-http-mac"/>, and the Holder-of-the-Key approach <xref target="I-D.tschofenig-oauth-hotk"/>.</t>

<t>To illustrate key confirmation the first examples borrows from Kerberos and symmetric key cryptography. Assume that Authorization Server shares a long-term secret with Resource Server, called K(Authorization Server-Resource Server). This secret would be established between them in an initial registration phase outside the scope of the actual protocol run. When Client requests a token Authorization Server creates a fresh and unique key Ks and places it into the token encrypted with K(Authorization Server-Resource Server). Additionally, Authorization Server attaches Ks when it sends the token to Client over a confidentialy protected channel. When Client sends a request to Resource Server it has to use Ks to sign the request (in whatever form or whatever layer). Resource Server, when receiving the message, retrieves the token, verifies it and uses K(Authorization Server-Resource Server) to decrypt Ks and to verify the signature.  
</t>
<t>Note that in this example one could imagine that the mechanism to protect the token itself is based on a symmetric key based mechanism to avoid any form of public key infrastructure but this aspect is not further eleborated in the scenario.</t>

<t>A similar mechanism can also be designed using asymmetric cryptography. When Client requests a token Authorization Server creates an ephemeral public / privacy key pair PK/SK and places the public key PK into the protected token. When Authorization Server returns the token to Client it also provides the PK/SK key pair over a confidentialy protected channel. When Client sends a request to Resource Server it has to use the privacy key SK to sign the request. Again, the details are secondary. Resource Server, when receiving the message, retrieves the token, verifies it and extracts the public key PK. It uses this ephemeral public key to verify the attached signature.</t>
</section> 
 
 
     <section title="Summary">

   <t> As a high level message, there are various ways how the threats can be mitigated and while the details of each solution is somewhat different they all ultimately accomplish the goal. </t>
   
   <t>The three approaches are: <list style="hanging">
   
   <t hangText="Confidentiality Protection:">The weak point with this approach, which is briefly described in <xref target="confidentiality"/>, is that the Client has to be careful to whom it discloses the access token. What can be done with the token entirely depends on what rights the token entitles the presenter and what constaints it contains. A token could encode the identity of the Client but there are scenarios where the Client is not authenticated to the Resource Server or where the identifier of the Client rather prepresents an application class rather than a single application instance. As such, it is possible that certain deployments choose a rather liberal approach to security and that everyone who is in possession of the access token is granted access to the data. 
   <!-- <vspace blankLines="1"/> 
   Furthermore, to secure the access token at rest; unauthorized disclosure could be harmful particularly when the token has a rather long lifetime. Intuitively, one would argue that access tokens are easy to mint and used for a small time duration only to reduce the risk of exposure.--> </t>
   
   <t hangText="Sender Constraint:">The weak point with this approach, which is briefly described in <xref target="intended"/>, is to setup the authentication infrastructure such that Clients can be authenticated towards Resource Servers. Additionally, Authorization Server must encode the identifier of the Client in the token for later verification by the Resource Server. Depending on the chosen layer for providing Client-side authentication there may be additional challenges due Web server load balancing, lack of API access to identity information, etc. 
</t>
   <t hangText="Key Confirmation:">The weak point with this approach, see <xref target="confirmation"/>, is the increased complexity: a complete key distribution protocol has to be defined.  
  </t>
   </list> 
   </t>

<t>In all cases above it has to be ensured that the Client is able to keep the credentials secret.</t> 
    </section> 
    
    
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

<section anchor="requirements" title="Requirements"> 

<t>In an attempt to address the threats described in <xref target="threats"/> the Bearer Token, which corresponds to the description in <xref target="confidentiality"/>, was standardized and the work on a JSON-based token format has been started. The required capability to protected the content of a JSON token using integrity  and confidentiality mechanisms is currently work in progress in the IETF JOSE working group.</t>

<t>Consequently, the purpose of this work is to provide security that goes beyond the Bearer Token offered security protection.</t>   

  <t>RFC 4962 <xref target="RFC4962"/> gives useful guidelines for designers of key management protocols. While RFC 4962 was written with the AAA framework used for network access authentication in mind the offered suggestions are useful for the design of other key management systems as well. The following list applies OAuth 2.0 terminology to the requirements outlined in RFC 4962.</t>
   
  <t>These requirements include 
   <list style="numbers">
   <t>Cryptographic algorithm independent:  The key management protocol MUST be cryptographic algorithm
         independent.</t>
         
   <t>Strong, fresh session keys: Session keys MUST be
         strong and fresh.  Each session deserves an independent session
         key. A fresh cryptographic key is one that is generated specifically
         for the intended use. In context of OAuth this means that keying material is created in such a way that can only be used between a specific tuple of Client instance, protected resource, and scope.</t>
         
   <t>Limit key scope: Following the principle of least privilege, parties MUST NOT
         have access to keying material that is not needed to perform
         their role. Any protocol that is used to establish session keys MUST
         specify the scope for session keys, clearly identifying the
         parties to whom the session key is available.</t>
         
   <t>Replay detection mechanism: The key management protocol exchanges MUST be replay
         protected. Replay protection allows a protocol message
         recipient to discard any message that was recorded during a
         previous legitimate dialogue and presented as though it
         belonged to the current dialogue.</t>
         
   <t>Authenticate all parties: Each party in the key management protocol MUST be
         authenticated to the other parties with whom they communicate.
         Authentication mechanisms MUST maintain the confidentiality of
         any secret values used in the authentication process. Secrets MUST NOT be sent to
         another party without confidentiality protection.</t>
         
   <t>Authorization: Client and Resource Server authorization MUST be performed.  These
         entities MUST demonstrate possession of the appropriate keying
         material, without disclosing it.  Authorization is REQUIRED
         whenever a Client interacts with an Authorization Server.  The
         authorization checking prevents an elevation of privilege
         attack, and it ensures that an unauthorized authorized is
         detected.</t>
         
   <t>Keying material confidentiality and integrity: While preserving algorithm independence, confidentiality and
         integrity of all keying material MUST be maintained.</t>
         
   <t>Confirm ciphersuite selection: The selection of the "best" ciphersuite SHOULD be securely
         confirmed.  The mechanism SHOULD detect attempted roll-back
         attacks.</t>
         
   <t>Uniquely named keys: key management proposals require a robust key naming
         scheme, particularly where key caching is supported.  The key
         name provides a way to refer to a key in a protocol so that it
         is clear to all parties which key is being referenced.  Objects
         that cannot be named cannot be managed.  All keys MUST be
         uniquely named, and the key name MUST NOT directly or
         indirectly disclose the keying material.  If the key name is
         not based on the keying material, then one can be sure that it
         cannot be used to assist in a search for the key value.</t>
         
   <t>Prevent the Domino effect: Compromise of a single Client MUST NOT compromise keying material
         held by any other Client within the system, including session
         keys and long-term keys.  Likewise, compromise of a single
         Resource Server MUST NOT compromise keying material held by any
         other Resource Server within the system.  In the context of a key
         hierarchy, this means that the compromise of one node in the
         key hierarchy must not disclose the information necessary to
         compromise other branches in the key hierarchy.  Obviously, the
         compromise of the root of the key hierarchy will compromise all
         of the keys; however, a compromise in one branch MUST NOT
         result in the compromise of other branches.  There are many
         implications of this requirement; however, two implications
         deserve highlighting.  First, the scope of the keying material
         must be defined and understood by all parties that communicate
         with a party that holds that keying material.  Second, a party
         that holds keying material in a key hierarchy must not share
         that keying material with parties that are associated with
         other branches in the key hierarchy.         
         </t>
   <t>Bind key to its context:  Keying material MUST be bound to the appropriate context.  The
         context includes the following.<list style="symbols"> 
         <t> The manner in which the keying material is expected to be
               used.</t>

         <t> The other parties that are expected to have access to the
               keying material.</t>

         <t> The expected lifetime of the keying material.  Lifetime
               of a child key SHOULD NOT be greater than the lifetime of
               its parent in the key hierarchy.</t>
         </list> 
         

         Any party with legitimate access to keying material can
         determine its context.  In addition, the protocol MUST ensure
         that all parties with legitimate access to keying material have
         the same context for the keying material.  This requires that
         the parties are properly identified and authenticated, so that
         all of the parties that have access to the keying material can
         be determined. The context will include the Client and the Resource Server identities in more
         than one form.</t>
         
   <t>Authorization restriction: If Client authorization is restricted, then the Client SHOULD be
         made aware of the restriction. </t>

   <t>Client Identity Confidentiality: A Client has identity confidentiality when any party other than
   the Resource Server and the Authorization Server cannot sufficiently identify the Client within the
   anonymity set. In comparison to anonymity and pseudonymity, identity
   confidentiality is concerned with eavesdroppers and intermediaries. A key management protocol SHOULD provide this property.</t>
        
    <t>Resource Owner Identity Confidentiality: Resource servers SHOULD be prevented from knowing the real or
      pseudonymous identity of the resource owner, since the Authorization Server
       is the only entity involved in verifying the resource owner's identity.</t>


   <t>Collusion: Resource servers that collude can be prevented from using information related to the resource owner to track the individual.  That is, two
      different Resource Servers can be prevented from determining that
      the same resource owner has authenticated to both of them.  This
      requires that each Authorization Server obtains different keying material as well as different access tokens
      with content that does not allow identification of the resource owner. </t>
   
   <t>AS-to-RS Relationship Anonymity: The Authorization Server can be prevented from knowing which Resource Servers
      an individual interacted with.  This requires avoiding
      direct communication between the Authorization Server and the Resource Server
      at the time when access to a protected resource by the Client is
      made. Is this a desireable property?</t>
   </list>
   </t>
   
   <t>As an additional requirement a solution MUST enable support for channel bindings. The concept of channel binding, as defined in <xref target="RFC5056"/>, allows applications to establish that
   the two end-points of a secure channel at one network layer are the
   same as at a higher layer by binding authentication at the higher
   layer to the channel at the lower layer.</t>
   
   <t>Furthermore, there are performance concerns specifically with the usage of asymmetric cryptography. As such, the requirement can be phrases as 'faster is better'.</t>

   <t>Finally, there are threats that relate to the experience of the software developer as well as operational policies. For example, a frequently raised concern is the absent of verifying that the server's presented identity matches its reference identity so it can authenticate the communication endpoint and authorize it. Verifying the server identity in TLS is discussed at length in <xref target="RFC6125"/>. There are also various guesses about what application developers are able to implement correctly and easily and to what degree they can rely on third party libraries.</t>

</section> 


    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="sec-cons" title="Security Considerations">
   
   <t>The main focus of this document is on security.</t>
   
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section title="Next Steps">
    <t>From this description so far a few observations and next steps can be derived:</t>
    <t>
    <list style="numbers">
    
    <t>Bearer Tokens are a viable solution for protecting against the threats described in <xref target="threats"/>. Further standardization work on OAuth security mechanisms needs to provide additional security benefits on top of those provided by the bearer token solution.</t>
    
    <t>The requirements listed in <xref target="requirements"/> aim to provide a starting point for a discussion on a security slution that provides additional security and privacy benefits for OAuth 2.0.</t>
    
    <t>It is likely that implementers will find security solutions hard to implement and hard to configure right. Additional guidance and the availability to libraries may help to improve security on the Internet for OAuth-based implementations. Fundamentally, there is the question about a design that is based on symmetric vs. asymmetric cryptography. Ideally, only a single solution should be developed (or a very small number) since the differences between different variations of such as protocol are minor.</t>
     
    <t>A standardized solution for the token format is needed to mitigate a number of attacks and this work is already ongoing under the name of JWT <xref target="I-D.ietf-oauth-json-web-token"/>.</t>
    
    </list>
    </t>
    
    <t>To make progress with the above-mentioned items before the next IETF meeting in Atlanta I therefore suggest to (a) solicit for document reviews regarding the JWT document, and (b) progress the work on the extended OAuth security mechanism. Regarding the latter aspect consider the following questions: 
    <list style="hanging">
   
   <t hangText="Threats:"> <xref target="threats"/> lists a few security threats. Are these the threats you care about? Which threats missing?</t>

<t hangText="Requirements:">The working group has expressed interest to work on an extended OAuth security mechanism. Assuming that the group wants to develop a key distribution protocol (as described in <xref target="confirmation"/>) are the requirements listed in <xref target="requirements"/> complete? Who is interested to develop early prototypes of support the standards development?</t>

</list>
</t>


    </section>



    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section anchor="iana" title="IANA Considerations">

    <t>This document does not require actions by IANA.</t>
    
    </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////// -->

    <section title="Acknowledgments">
      <t>The authors would like to thank the OAuth working group for their discussion input.
      A group of regular OAuth participants met at the IETF #82 meeting in Vancouver to discuss this topic in preparation for the face-to-face meeting. The participants were: 
      <list style="symbols"> 
      <t>John Bradley</t>
      <t>Brian Campbell</t>
      <t>Phil Hunt</t>      
      <t>Leif Johansson</t>
      <t>Mike Jones</t>
      <t>Lucy Lynch</t>
      <t>Tony Nadalin</t>
      <t>Klaas Wierenga</t>
      </list> 
      </t>
     
     <t>This document reuses content from <xref target="RFC4962"/> and the author would like thank Russ Housely and Bernard AResource Servera for their work on that document.</t> 
      
     <t>Finally, I would like to thank Blaine Cook. This document was derived from an earlier draft that Blaine and I wrote.</t>     
    </section>
 </middle>

  <!-- ////////////////////////////////////////////////////////////////////////////////// -->

  <back>
    <references title="Normative References">
      <reference anchor="RFC2119">
        <front>
          <title abbrev="RFC Key Words">Key words for use in RFCs to Indicate Requirement Levels</title>
          <author fullname="Scott Bradner" initials="S." surname="Bradner">
            <organization>Harvard University</organization>
          </author>
          <date month="March" year="1997"/>
        </front>
        <format octets="4723" target="ftp://ftp.isi.edu/in-notes/rfc2119.txt" type="TXT"/>
      </reference>
      
 &I-D.ietf-oauth-v2; &RFC4949;
 &I-D.ietf-oauth-v2-bearer; 
 &I-D.ietf-oauth-json-web-token;
 </references>

    <references title="Informative References">
&RFC4962; 
&I-D.iab-privacy-considerations;
&RFC4279;
&RFC5246;
&RFC4120;
&I-D.hardjono-oauth-kerberos;
&I-D.rescorla-stateless-tokens;
&RFC5849;
&RFC5056;
&RFC6125;
&I-D.ietf-oauth-v2-http-mac;
&I-D.tschofenig-oauth-hotk;

    <reference anchor="NIST800-63">
        <front>
          <title>NIST Special Publication 800-63-1, INFORMATION SECURITY</title>
          <author fullname="William E. Burr" initials="W." surname="Burr">
            <organization>NIST</organization>
          </author>
          <author fullname="Donna F. Dodson" initials="D." surname="Dodson">
            <organization>NIST</organization>
          </author>
          <author fullname="Ray A. Perlner" initials="R." surname="Perlner">
            <organization>NIST</organization>
          </author>
          <author fullname="W. Timothy Polk" initials="T." surname="Polk">
            <organization>NIST</organization>
          </author>
          <author fullname="Sarbari Gupta" initials="S." surname="Gupta">
            <organization>NIST</organization>
          </author>
          <author fullname="Emad A. Nabbus" initials="E." surname="Nabbus">
            <organization>NIST</organization>
          </author>
          <date month="December" year="2008"/>
        </front>
        <format target="http://csrc.nist.gov/publications/PubsDrafts.html#SP-800-63-Rev.%201" type="HTML"/>
     </reference>
          
     </references> 
  </back>
</rfc>
