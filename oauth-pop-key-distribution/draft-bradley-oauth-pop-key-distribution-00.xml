<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" []>
<?xml-stylesheet type='text/xsl' href='http://xml.resource.org/authoring/rfc2629.xslt' ?>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="no"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc strict="no"?>
<?rfc compact="no"?>
<?rfc subcompact="no"?>

<rfc category="std" ipr="trust200902"
docName="draft-bradley-oauth-pop-key-distribution-00.txt">

  <front>
  <title abbrev="OAuth 2.0 PoP: AS-Client Key Distribution">OAuth 2.0 Proof-of-Possession: Authorization Server to Client Key Distribution</title>   

    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization abbrev="Ping Identity">Ping Identity</organization>
      <address>
	<email>ve7jtb@ve7jtb.com</email>
      </address>
    </author>

      <author fullname="Phil Hunt" initials="P." surname="Hunt">
      <organization>Oracle Corporation</organization>

      <address>
        <email>phil.hunt@yahoo.com</email>
      </address>
    </author>
    
    
    <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
      <organization abbrev="Microsoft">Microsoft</organization>

      <address>
        <email>mbj@microsoft.com</email>
      </address>
    </author>


    <author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
      <organization>ARM Limited</organization>
      <address>
        <postal>
          <street></street>
          <city></city>
          <code></code>
          <country>Austria</country>
        </postal>
        <phone></phone>
        <email>Hannes.Tschofenig@gmx.net</email>
        <uri>http://www.tschofenig.priv.at</uri>
      </address>
    </author>

    <date year="2014"/>
    <keyword>Internet-Draft</keyword>
    <keyword>OAuth</keyword>
    <keyword>Security</keyword>
    <keyword>Authorization</keyword>
        <keyword>Key Distribution</keyword>
    <keyword>Proof-of-Possession</keyword>

    <abstract>

  <t>RFC 6750 specified the bearer token concept for securing access to protected resources. Bearer tokens need to be protected in transit as well as at rest since the security model is based on proof-of-possession.</t> 
  
  <t>The OAuth 2.0 Proof-of-Possession security concept extends bearer token security and requires the client to demonstrate possession of a key when accessing a protected resource.</t>
  
  <t>This document describes how the client obtains this keying material from the authorization server.</t>

</abstract>

  </front>
  <middle>

<!-- ====================================================================== -->

<section anchor="introduction" title="Introduction">

   <t><xref target="I-D.hunt-oauth-pop-architecture"/> motivates the work on additional security mechanisms beyond OAuth 2.0 bearer tokens <xref target="RFC6750"/> and outlines use cases, requirements and an architecture. This document defines the ability for the client to obtain keying material from the authorization server. This keying material is linked to an access token.</t>

  <t>To best describe the scope of this specification, the OAuth 2.0 protocol exchange sequence is shown in <xref target="oauth-flow"/>.
	  The extension defined in this document piggybacks on the message exchange marked with (C) and (D).</t>
  
  	  <t>
        <figure anchor="oauth-flow" title="Abstract OAuth 2.0 Protocol Flow">
          <artwork><![CDATA[
     +--------+                               +---------------+
     |        |--(A)- Authorization Request ->|   Resource    |
     |        |                               |     Owner     |
     |        |<-(B)-- Authorization Grant ---|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(C)-- Authorization Grant -->| Authorization |
     | Client |                               |     Server    |
     |        |<-(D)----- Access Token -------|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------>|    Resource   |
     |        |                               |     Server    |
     |        |<-(F)--- Protected Resource ---|               |
     +--------+                               +---------------+		  
]]></artwork>
        </figure>
	  </t>
	  
	  
	  	  <t>OAuth 2.0 <xref target="RFC6749"/> offers different ways to obtain an access token, namely 
	  using authorization grants and using a refresh token. The core OAuth 
	  specification defines four authorization grants, see Section 1.3 of <xref target="RFC6749"/>, and 
	  <xref target="I-D.ietf-oauth-assertions"/> adds an assertion-based authorization grant to that list.</t> 
	  
	  <t>This document extends the communication with the token endpoint. The token
   endpoint, which is described in Section 3.2 of <xref target="RFC6749"/>, is used with every authorization grant except for the implicit grant type. In the implicit grant type the access token is issued directly.</t>
   
   <t>Two types of keying material can be bound to an access token, namely symmetric keys and asymmetric keys. Conveying symmetric keys from the authorization server to the client is described in <xref target="symmetric"/> and the procedures for dealing with asymmetric keys are described in <xref target="asymmetric"/>. </t>
   
</section>

<!-- ************************************************************************************** --> 

<section title="Terminology">
   <t>The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL NOT',
   'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'MAY', and 'OPTIONAL' in this
   specification are to be interpreted as described in <xref target="RFC2119"/>.</t>
   
  <t><list style="hanging">
		
		<t hangText="Session Key:"><vspace blankLines="1"/>
		The term session key refers to fresh and unique keying material established between the client and the resource server. This session key has a lifetime that corresponds to the lifetime of the access token, is generated by the authorization server and bound to the access token.<vspace blankLines="1"/></t>
	  
	   </list>
	  </t>
</section> 

	  
<!-- ************************************************************************************** --> 

<section title="Audience"> 

 <t>When an authorization server creates an access token, according to the PoP security architecture it has to know which resource server will process it. This section defines a new header that is used by the client to indicate what protected resource at which resource server it wants to access. This information may subsequently also communicated by the authorization server securely to the resource server, for example within the audience field of the access token.</t>
	
	   <section title='Audience Parameter'>
	
	<t>Before a client wants to interact with a resource server it needs to obtain an access token. It therefore constructs the access token request to the token endpoint by adding the audience parameter using the "application/x-www-form-urlencoded" format with a character encoding of UTF-8 in the HTTP
   request entity-body.</t>
	
	<t>The audience URI MUST be an absolute URI as defined by Section 4.3 of <xref target="RFC3986"/>. It MAY include an
   "application/x-www-form-urlencoded" formatted query component (Section 3.4 of <xref target="RFC3986"/> ). The URI MUST NOT include a
   fragment component.</t>
   
   <t>The ABNF syntax is defined as follows where by the "URI-reference" definition is taken from <xref target="RFC3986"/>:</t>
   
   <t>audience      = URI-reference</t>

   </section>
   
   
   <section title="Processing Instructions">

    <t><list style="empty">
	 
     <t>Step (0): As an initial step the client typically determines the resource server it wants to interact with, for example, as part of a discovery procedure.</t>
	 
	<t>Step (1): The client starts the OAuth 2.0 protocol interaction based on the selected grant type. </t>
	  
	 <t>Step (2): When the client interacts with the token endpoint to obtain an access token it MUST populate the newly defined 'audience' parameter with the information obtained in step (0).</t>
     
     <t>Step (2): The resource server who obtains the request needs to parse it to determine whether the provided audience value matches any of the resource servers it has a relationship with. If the authorization server fails to parse the provided value it MUST reject the request using an error response with the error code "invalid_request". If the authorization server does not consider the resource server acceptable it MUST return an error response with the error code "access_denied". In both cases additional error information may be provided via the error_description, and the error_uri parameters. If the request has, however, been verified successfully then the authorization server MUST include the audience claim into the access token with the value copied from the audience field provided by the client. In case the access token is encoded using the JSON Web Token format <xref target="I-D.ietf-oauth-json-web-token"/> the "aud" claim MUST be used. The access token MUST be protected against modification by either using a digital signature or a keyed message digest. The authorization server returns the access token to the client, as specified in <xref target="RFC6749"/>.</t>
     
   </list></t>
	 
	 <t>Subsequent steps for the interaction between the client and the resource server are beyond the scope of this document.</t> 
	
   </section> 
</section> 
	  
<!-- ************************************************************************************** --> 

   <section anchor="symmetric" title="Symmetric Key Transport"> 
   
   <t>In case a symmetric key shall be bound to an access token the following procedure is applicable. In the request message from the OAuth client to the authorization server the following parameters MUST be included: 
        </t>
        <t>
          <list style='hanging' hangIndent='6'>
            <t hangText='token_type:'>
              REQUIRED. For the symmetric key variant the value MUST be set to "sk". 
            </t>
            <t hangText='profile:'>
              REQUIRED. The profile parameter provides information about what mechanisms the client supports to provide proof of possession of the key towards a resource server. The value MUST be taken from the algorithm registry created in <xref target='profile-registry' />. Algorithm names are case-sensitive. If the client supports more than one algorithm profile then each individual value MUST be separated by a comma.
            </t>
              
          </list>
        </t>
   
      <t>For example, the client makes the following HTTP request using TLS
   (extra line breaks are for display purposes only):
   
          <figure title="Example Request to the Authorization Server">
            <artwork>
              <![CDATA[
     POST /token HTTP/1.1
     Host: server.example.com
     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
     Content-Type: application/x-www-form-urlencoded;charset=UTF-8

     grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA
     &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
     &token_type=sk
     &profile=foo-bar
]]>
          </artwork>
        </figure>
      </t>
    
       <t>If the access token request is valid and authorized, the
   authorization server issues an access token and optionally a refresh
   token. If the request client authentication failed or is invalid, the authorization server returns
   an error response as described in Section 5.2 of <xref target="RFC6749"/>.</t>

         <t>The authorization server MUST include a JWK in a successful response, if it supports any of the profiles listed by the client. 
        </t>
       
        <t>
        <figure>
          <preamble>
            For example:
          </preamble>
          <artwork>
            <![CDATA[
  HTTP/1.1 200 OK
  Content-Type: application/json
  Cache-Control: no-store

  {
    "access_token":"SlAV32hkKG ... 
      ... (remainder of JWT omitted for brevity)",
    "token_type":"sk",
    "expires_in":3600,
    "refresh_token":"8xLOxBtZp8",
    "jwk":"eyJhbGciOiJSU0ExXzUi ...
      ... (remainder of JWK omitted for brevity)"
  }
  
  The content of the 'access_token' contains 
  the key identifier value in the 'cnf' element, 
  as shown below. 
   
   {
      "iss": "https://server.example.com",
      "sub": "24400320",
      "aud": "s6BhdRkqt3",
      "nonce": "n-0S6_WzA2Mj",
      "exp": 1311281970,
      "iat": 1311280970,
      "cnf":{
        "jwk":
          "JDLUhTMjU2IiwiY3R5Ijoi ...
           ... (remainder of JWE omitted for brevity)"
        }
   }
    
]]>
          </artwork>
        </figure>
      </t>
   </section> 
   
   	  
<!-- ====================================================================== -->

   <section anchor="asymmetric" title="Asymmetric Key Transport"> 
   
   <t>In case an asymmetric key shall be bound to an access token then the following procedure is applicable. In the request message from the OAuth client to the authorization server the following parameters MUST be included: 
        </t>
        <t>
          <list style='hanging' hangIndent='6'>
            <t hangText='token_type:'>
              REQUIRED. For the asymmetric key variant the value MUST be set to "pk". 
            </t>
            <t hangText='pk_info:'>
              OPTIONAL. This field contains information about the public key the client would like to bind to the access token in the JSON Web Key format. If the client does not provide a public key then the authorization server MUST create an ephemeral key pair (considering the profile information provided by the client) or alternative respond with an error message. 
            </t>
<!--             <t hangText='algorithms:'>TBD.</t> --> 
            
            <t hangText='profile:'>
              REQUIRED. The profile parameter provides information about what mechanisms the client supports to provide proof of possession of the key towards a resource server. The value MUST be taken from the algorithm registry created in <xref target='profile-registry' />. Algorithm names are case-sensitive. If the client supports more than one profile then each individual value MUST be separated by a comma. 
            </t>
               
          </list>
        </t>

   <t>For example, the client makes the following HTTP request using TLS
   (extra line breaks are for display purposes only):
   
          <figure title="Example Request to the Authorization Server">
            <artwork>
              <![CDATA[
     POST /token HTTP/1.1
     Host: server.example.com
     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
     Content-Type: application/x-www-form-urlencoded;charset=UTF-8

     grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA
     &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
     &token_type=pk
     &pk_info:"eyJhbGciOiJSU0ExXzUi ...
      ... (remainder of JWK omitted for brevity)"

   whereby the content of the pk_info field represents the following
   structure:

  {"keys":
     [
       {"kty":"RSA",
          "n": "0vx7agoebGcQSuuPiLJXZptN9nndrQmbXEps2aiAFbWhM78LhWx
     4cbbfAAtVT86zwu1RK7aPFFxuhDR1L6tSoc_BJECPebWKRXjBZCiFV4n3oknjhMs
     tn64tZ_2W-5JsGY4Hc5n9yBXArwl93lqt7_RN5w6Cf0h4QyQ5v-65YGjQR0_FDW2
     QvzqY368QQMicAtaSqzs8KJZgnYb9c7d0zgdAZHzu6qMQvRL5hajrn1n91CbOpbI
     SD08qNLyrdkt-bFTWhAI4vMQFh6WeZu0fM4lFd2NcRwr3XPksINHaQ-G_xBniIqb
     w0Ls1jF44-csFCur-kEgU8awapJzKnqDKgw",
          "e":"AQAB",
          "alg":"RS256",
        "kid":"client@example.com"}
     ]
   }
   ]]></artwork>
   </figure>
   </t>
      
   <t>If the access token request is valid and authorized, the
   authorization server issues an access token and optionally a refresh
   token.  If the request client authentication failed or is invalid, the authorization server returns
   an error response as described in Section 5.2 of <xref target="RFC6749"/>.</t>
   
   <t>The authorization server also places information 
   about the public key used by the client into the access token to create the 
   binding between the two. The new token type, called 'pk', is placed into the 'token_type' parameter. </t>

   <t>An example of a successful response is shown below:

          <figure title="Example Response from the Authorization Server">
            <artwork>
              <![CDATA[
     HTTP/1.1 200 OK
     Content-Type: application/json;charset=UTF-8
     Cache-Control: no-store
     Pragma: no-cache

     {
       "access_token":"2YotnFZFE....jr1zCsicMWpAA",
       "token_type":"pk",
       "expires_in":3600,
       "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA"
     }   

    whereby the content of the 'access_token' field, for example, 
    contains an encoded JWT with the following structure:
   
    HEADER: 
    
    {"typ":"JWT",
     "alg":"HS256"}
     
    BODY:
    
    {
      "iss":"xas.example.com",
      "aud":"http://auth.example.com",
      "exp":"1361398824",
      "nbf":"1360189224",
      "cnf":{
        "jwk":{"kty":"RSA",
          "n": "0vx7agoebGcQSuuPiLJXZptN9nndrQmbXEps2aiAFbWhM78LhWx
     4cbbfAAtVT86zwu1RK7aPFFxuhDR1L6tSoc_BJECPebWKRXjBZCiFV4n3oknjhMs
     tn64tZ_2W-5JsGY4Hc5n9yBXArwl93lqt7_RN5w6Cf0h4QyQ5v-65YGjQR0_FDW2
     QvzqY368QQMicAtaSqzs8KJZgnYb9c7d0zgdAZHzu6qMQvRL5hajrn1n91CbOpbI
     SD08qNLyrdkt-bFTWhAI4vMQFh6WeZu0fM4lFd2NcRwr3XPksINHaQ-G_xBniIqb
     w0Ls1jF44-csFCur-kEgU8awapJzKnqDKgw",
          "e":"AQAB",
          "alg":"RS256",
        "kid":"client@example.com"}
       }
     }
   INTEGRITY PROTECTION:
     ... not shown ... 
    ]]></artwork>
   </figure>
   </t>
   
   	  </section> 
	  
<!-- ====================================================================== -->

<section anchor="SecurityConsiderations" title="Security Considerations">
  
  <t><xref target="I-D.hunt-oauth-pop-architecture"/> describes the architecture for the OAuth 2.0 proof-of-possession security architecture, including use cases, threats, and requirements.
  This requirements describes one solution component of that architecture, namely the mechanism for the client to interact with the authorization server to either obtain a symmetric key from the authorization server, to obtain an asymmetric key pair, or to offer a public key to the authorization. In any case, these keys are then bound to the access token by the authorization server. 
  </t>

   <t>To summarize the main security recommendations: A large range of threats can be mitigated by protecting the contents
   of the access token by using a digital signature or a keyed message digest. 
   Consequently, the token integrity protection MUST be applied 
   to prevent the token from being modified, particularly since it contains a reference to the symmetric key or the asymmetric key.
   If the access token contains the symmetric key (see Section 2.2 of <xref target="I-D.jones-oauth-proof-of-possession"/> for a description about how symmetric keys can be securely conveyed within the access token) this symmetric key MUST be encrypted by the authorization server with a long-term key shared with the resource server. </t>

   <t>To deal with token redirect, it is important for the authorization
   server to include the identity of the intended recipient (the
   audience), typically a single resource server (or a list of resource
   servers), in the token. Using a single shared secret with multiple authorization server to simplify key management is 
   NOT RECOMMENDED since the benefit from using the proof-of-possession concept is significantly reduced. </t>

   <t>Token replay is also not possible since an eavesdropper will also have to obtain 
   the corresponding private key or shared secret that is bound to the access token. 
   Nevertheless, it is good practice to limit the lifetime of the access token and therefore the lifetime 
   of associated key.
   </t>
   
   <t>The authorization server MUST offer confidentiality protection for any interactions with the client. 
   This step is extremely important since the client will obtain the session key from the authorization server for use with a specific 
   access token. Not using confidentiality protection exposes this secret (and the access token) to an eavesdropper thereby making the OAuth 2.0 proof-of-possession security model completely insecure. 
   OAuth 2.0 <xref target="RFC6749"/> relies on TLS to offer confidentiality protection and additional protection can be applied using the JSON Web Key (JWK) <xref target="I-D.ietf-jose-json-web-key"/> offered security mechanism, which would add an additional layer of protection on top of TLS for cases where the keying material is conveyed, for example, to a hardware security module. Which version(s) of TLS ought
   to be implemented will vary over time, and depend on the widespread
   deployment and known security vulnerabilities at the time of
   implementation.  At the time of this writing, TLS version 1.2
   <xref target="RFC5246"/> is the most recent version. The
   client MUST validate the TLS certificate chain when making requests
   to protected resources, including checking the validity of the certificate. 
   </t> 
  
   <t>Similarly to the security recommendations for the bearer token specification <xref target="RFC6750"/> developers MUST ensure that the ephemeral 
   credentials (i.e., the private key or the session key) is not leaked to third parties. An adversary in possession of the ephemeral credentials bound to the access token will be able to impersonate the client.
   Be aware that this is a real risk with many smart phone app and Web development environments.</t>


 <t>Clients can at any time request a new proof-of-possession capable access token. Using a refresh token to regularly request new access tokens that are bound to fresh and unique keys is important. Keeping the lifetime of the access token short allows the authorization server to use shorter key sizes, which translate to a performance benefit for the client and for the resource server. Shorter keys also lead to shorter messages (particularly with asymmetric keying material).</t> 
   
   <t>When authorization servers bind access tokens to symmetric keys then they MUST scope these access tokens to a specific resource server.</t> 


</section> 


<!-- ====================================================================== -->
<!-- 
<section anchor="PrivacyConsiderations" title="Privacy Considerations">
  <t>TBD</t>
</section>
--> 
<!-- ====================================================================== -->

<section anchor="iana" title="IANA Considerations">

<t>This document requires IANA to take the following actions.</t> 

<section title="OAuth Parameters Registration"> 

<t>This specification registers the following parameters in the OAuth Parameters Registry established by <xref target="RFC6749"/>.</t>

<t><list style="hanging"> 
<t hangText="Parameter name:"> pk_info</t>
<t hangText="Parameter usage location:"> token request</t>
<t hangText="Change controller:"> IETF</t>
<t hangText="Specification document(s):">  [[ this document ]]</t>
<t hangText="Related information:">  None</t>
</list> 
</t> 

<t><list style="hanging"> 
<t hangText="Parameter name:"> token_type</t>
<t hangText="Parameter usage location:"> token request, token response, authorization response</t>
<t hangText="Change controller:"> IETF</t>
<t hangText="Specification document(s):">  [[ this document ]]</t>
<t hangText="Related information:">  None</t>
</list> 
</t> 

<t><list style="hanging"> 
<t hangText="Parameter name:"> profile</t>
<t hangText="Parameter usage location:"> token request, token response, authorization response</t>
<t hangText="Change controller:"> IETF</t>
<t hangText="Specification document(s):">  [[ this document ]]</t>
<t hangText="Related information:">  None</t>
</list> 
</t> 



<t><list style="hanging"> 
<t hangText="Parameter name:"> jwk</t>
<t hangText="Parameter usage location:"> token response, authorization response</t>
<t hangText="Change controller:"> IETF</t>
<t hangText="Specification document(s):">  [[ this document ]]</t>
<t hangText="Related information:">  None</t>
</list> 
</t> 

<t><list style="hanging"> 
<t hangText="Parameter name:"> audience</t>
<t hangText="Parameter usage location:"> token request</t>
<t hangText="Change controller:"> IETF</t>
<t hangText="Specification document(s):"> [[This document.]</t>
<t hangText="Related information:">  None</t>
</list> 
</t
>
</section> 

<!-- 
<section title="The 'hotk' OAuth Access Token Type"> 

<t>Section 11.1 of <xref target="RFC6749"/> defines the OAuth Access Token Type Registry and 
this document adds another token type to this registry.</t> 

<t><list style="hanging"> 

<t hangText="Type name:"> hotk</t>

<t hangText="Additional Token Endpoint Response Parameters:"> (none)</t>

<t hangText="HTTP Authentication Scheme(s):"> Holder of the key confirmation using TLS </t>

<t hangText="Change controller:"> IETF</t>

<t hangText="Specification document(s):"> [[ this document ]]</t>
</list> 
</t>

</section>

--> 

<section anchor="profile-registry" title="Profile Registry"> 

<t>This document asks IANA to create a registry for proof-of-possession mechanisms for use with OAuth 2.0. 
The policy for adding new entries to the registry is "Specification Required". IANA is asked to populate the registry with the following values: </t>
          <t>
            <list style='symbols'>
              <t>
                Profile name: jws
              </t>
              <t>
                Change controller: IETF
              </t>
              <t>
                Specification document(s): [[ this document ]]
              </t>
            </list>
          </t>
          <t>
            <list style='symbols'>
              <t>
                Profile name: mac
              </t>
              <t>
                Change controller: IETF
              </t>
              <t>
                Specification document(s): [[ this document ]]
              </t>
            </list>
          </t>
  </section>

</section> 

<!-- ====================================================================== -->
    
<section title="Acknowledgements">
  <t>TBD.
  </t>
</section>

  </middle>

<!-- ====================================================================== -->
  <back>

    <references title="Normative References"> 
<?rfc include="reference.RFC.2119"?>
<!-- <?rfc include="reference.RFC.2616"?> --> 
<?rfc include="reference.RFC.6749"?>
<?rfc include="reference.RFC.3986"?>
      
      
      
      
      <?rfc include="reference.I-D.ietf-jose-json-web-key"?>
<!--      <?rfc include="reference.I-D.ietf-tls-oob-pubkey"?> --> 
      <?rfc include="reference.I-D.ietf-oauth-json-web-token"?>
      <?rfc include="reference.I-D.ietf-jose-json-web-signature"?>
            <?rfc include="reference.I-D.jones-oauth-proof-of-possession"?>
      

      
      <?rfc include="reference.RFC.5246"?>
 <!--     <?rfc include="reference.RFC.5280"?> --> 
      
    </references> 

    
    <references title="Informative References"> 
    <?rfc include="reference.I-D.hunt-oauth-pop-architecture"?>


<?rfc include="reference.RFC.6750"?>
<?rfc include="reference.I-D.ietf-oauth-assertions"?>

<!--

<?rfc include="reference.RFC.5849"?>


    <reference anchor="NIST800-63">
        <front>
          <title>NIST Special Publication 800-63-1, INFORMATION SECURITY</title>
          <author fullname="William E. Burr" initials="W." surname="Burr">
            <organization>NIST</organization>
          </author>
          <author fullname="Donna F. Dodson" initials="D." surname="Dodson">
            <organization>NIST</organization>
          </author>
          <author fullname="Ray A. Perlner" initials="R." surname="Perlner">
            <organization>NIST</organization>
          </author>
          <author fullname="W. Timothy Polk" initials="T." surname="Polk">
            <organization>NIST</organization>
          </author>
          <author fullname="Sarbari Gupta" initials="S." surname="Gupta">
            <organization>NIST</organization>
          </author>
          <author fullname="Emad A. Nabbus" initials="E." surname="Nabbus">
            <organization>NIST</organization>
          </author>
          <date month="December" year="2008"/>
        </front>
        <format target="http://csrc.nist.gov/publications/PubsDrafts.html#SP-800-63-Rev.%201" type="HTML"/>
    </reference>
            
      --> 

    </references>
  </back>
</rfc>
